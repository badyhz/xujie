<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Dashboard · 经典UI（浮动当前轴 + 侧栏全数值）</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{
      --bg:#0a0f1f; --card:#0f1632; --line:rgba(255,255,255,.12);
      --text:#d7defc; --muted:#96a2c9;
      --blue:#7c9bff; --green:#22c55e; --amber:#f59e0b;
      --ok:#22c55e; --bad:#fb7185;
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 60% -50%,#162147 0%,#0a0f1f 48%,#070b17 100%);
         color:var(--text); font:14px/1.55 Inter,"Noto Sans SC",system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;}
    .wrap{display:grid; grid-template-columns: 1.25fr .75fr; gap:18px; padding:20px; max-width:1280px; margin:0 auto;}
    .card{background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px 16px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative}
    .header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px}
    h1{font-size:18px; margin:0}
    .toolbar{display:flex; gap:8px; align-items:center}
    .btn{border:1px solid var(--line); background:rgba(255,255,255,.05); color:var(--text); padding:6px 10px; border-radius:10px; cursor:pointer}
    .btn:hover{background:rgba(255,255,255,.09)}
    .muted{color:var(--muted)}
    #chart{width:100%; height:620px}
    .panel{display:grid; gap:10px}
    .box{border:1px solid var(--line); border-radius:12px; padding:10px 12px; background:rgba(255,255,255,.03)}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
    .grid3{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
    .tag{display:inline-flex; padding:4px 8px; border-radius:9px; border:1px solid var(--line); gap:6px; align-items:center; margin:2px 6px 0 0; background:rgba(255,255,255,.04)}
    .rowtag{display:flex; flex-wrap:wrap; align-items:center}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; align-items:center}
    .kv .k{color:var(--muted)} .kv .v{font-weight:600}
    .badge{display:inline-flex; padding:6px 8px; border-radius:8px; border:1px solid var(--line); margin:4px 6px 0 0; background:rgba(255,255,255,.04)}
    .hint{font-size:12px; color:var(--muted)}
    .ok{color:var(--ok)} .bad{color:var(--bad)}

    .hovercard{
      position:absolute; pointer-events:none; min-width:220px; max-width:300px;
      background:rgba(15,22,50,.96); color:var(--text); border:1px solid var(--line); border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,.35); padding:10px 12px; transform:translate(12px,12px);
      display:none; z-index:20;
    }
    .hovercard .title{font-weight:700; margin:0 0 6px 0}
    .hovercard .kv2{display:grid; grid-template-columns: auto 1fr; gap:4px 10px; align-items:center; font-size:13px}
    .hovercard .kv2 .k{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="chartCard">
      <div class="header">
        <h1>结构（内）→ 生态（中）→ 潜力（外） · 经典UI</h1>
        <div class="toolbar">
          <button id="btnDemo" class="btn">注入演示数据</button>
          <button id="btnClear" class="btn">清空数据</button>
          <span id="diag" class="muted"></span>
        </div>
      </div>
      <div id="chart"></div>
      <div id="hoverCard" class="hovercard">
        <div class="title" id="hcTitle">—</div>
        <div class="kv2">
          <div class="k">生态</div><div class="v" id="hcEco">—</div>
          <div class="k">结构(投影)</div><div class="v" id="hcStruct">—</div>
          <div class="k">潜力(投影)</div><div class="v" id="hcPot">—</div>
        </div>
        <div class="k" style="margin-top:6px">关联来源</div>
        <div class="rowtag" id="hcLinks"></div>
      </div>
      <div class="hint">说明：当前轴信息采用<strong>浮动卡</strong>显示；完整数值在右侧列表。指南针=0.50C+0.30ES+0.20O；“关系稳定性”=连续性×韧性；A–J 情境徽章仅展示。</div>
    </div>

    <div class="panel">
      <div class="box">
        <b>结构 8 维</b>
        <div id="listStruct" class="rowtag" style="margin-top:6px"></div>
      </div>
      <div class="box">
        <b>生态 16 维</b>
        <div id="listEco" class="rowtag" style="margin-top:6px"></div>
      </div>
      <div class="box">
        <b>潜力 8 维</b>
        <div id="listPot" class="rowtag" style="margin-top:6px"></div>
      </div>
      <div class="box">
        <div style="display:flex; align-items:center; justify-content:space-between">
          <b>方标标签解读（已触发）</b>
          <span class="hint">仅展示，不改分</span>
        </div>
        <div id="badges" style="margin-top:6px"></div>
      </div>
    </div>
  </div>

<script>
const clamp01 = v => Math.max(0, Math.min(100, v));
const R = Math.round;
const pick = (o,k,d=0)=> (o&&k in o)? o[k] : d;
function parseAny(v){ if(!v) return null; try{return JSON.parse(v)}catch(e){return null} }

function injectDemo(){
  const self = {O:68,C:72,E:70,A:60,N:42};
  const env  = {O:60,C:65,E:62,A:58,N:48};
  localStorage.setItem('selfScores', JSON.stringify(self));
  localStorage.setItem('envScores', JSON.stringify(env));
  return {self, env};
}
function clearData(){ ['selfScores','envScores','SELF_SCORES','ENV_SCORES'].forEach(k=>localStorage.removeItem(k)); }

function loadVectors(){
  const selfRaw = parseAny(localStorage.getItem('selfScores')) || parseAny(localStorage.getItem('SELF_SCORES'));
  const envRaw  = parseAny(localStorage.getItem('envScores'))  || parseAny(localStorage.getItem('ENV_SCORES'));
  function toVector5(any){
    if (!any) return null;
    if (Array.isArray(any) && any.length>=5) return {O:any[0],C:any[1],E:any[2],A:any[3],N:any[4]};
    if (typeof any==='object'){
      const O=pick(any,'O'), C=pick(any,'C'), E=pick(any,'E'), A=pick(any,'A'), N=pick(any,'N');
      if ([O,C,E,A,N].every(x=>typeof x==='number')) return {O,C,E,A,N};
    }
    return null;
  }
  return { SELF: toVector5(selfRaw), ENV: toVector5(envRaw) };
}

const structNames=['镜面','筋骨','水流','火焰','指南针','盾牌','桥梁','岩石'];
const ecoNames=['信任建立速度','合作倾向','表达清晰度','独立程度','创造力','学习节奏','执行力','关系稳定性','风险感知','适应力','情绪感染力','冲突处理方式','信息组织','优化策略','领导气场','环境适应力'];
const potNames=['创新潜力','领导潜力','执行潜力','协作潜力','韧性潜力','创业潜力','幸福潜力','科研潜力'];

const mapSE={ 0:[0,2,5], 1:[3,6,8], 2:[9,4,7], 3:[10,11,14], 4:[3,2,14], 5:[11,7,0], 6:[0,1,7], 7:[6,5,8] };
const pot2eco={0:[4,9,12],1:[10,11,14],2:[6,12,3],3:[0,1,7],4:[7,8,9],5:[14,9,3],6:[5,7,1],7:[12,8,5]};

function toStructures5({O,C,E,A,N}){
  const ES = 100 - N;
  return [
    clamp01(0.60*O + 0.40*ES),
    clamp01(0.70*C + 0.30*ES),
    clamp01(0.60*O + 0.40*E),
    clamp01(0.60*E + 0.40*O),
    clamp01(0.50*C + 0.30*ES + 0.20*O),
    clamp01(0.80*ES + 0.20*C),
    clamp01(0.60*E + 0.40*A),
    clamp01(0.70*C + 0.30*ES)
  ];
}
function envParams(ENV){
  const gamma = clamp01((ENV.O + ENV.E)/2);
  const delta = clamp01((ENV.C + ENV.A)/2);
  const epsilon = clamp01(ENV.N);
  return {gamma,delta,epsilon};
}
function toEcology(structs, ENV){
  const eco=new Array(16).fill(50);
  structs.forEach((sv,si)=> (mapSE[si]||[]).forEach(ax=> eco[ax]+=0.35*(sv-50)));
  const {gamma,delta,epsilon}=envParams(ENV);
  const corr = 0.05*(gamma-50)+0.05*(delta-50)-0.04*(epsilon-50);
  for(let i=0;i<16;i++) eco[i]+=corr;
  const shield=structs[5], bone=structs[1], bridge=structs[6], water=structs[2], mirror=structs[0], compass=structs[4];
  const continuity = 0.45*shield + 0.35*bone + 0.20*bridge - 0.20*epsilon;
  const resilience = 0.40*water + 0.25*mirror + 0.20*bridge + 0.15*compass - 0.10*epsilon;
  eco[7] = clamp01(0.6*continuity + 0.4*resilience);
  return eco.map(Math.round);
}
function toPotentials(structs,eco,ENV){
  const {epsilon}=envParams(ENV); const s=structs,e=eco; const v=new Array(8).fill(50);
  v[0]=clamp01(0.30*s[2]+0.20*s[0]+0.20*e[4]+0.15*e[9]+0.15*e[12]);
  v[1]=clamp01(0.25*s[3]+0.20*s[6]+0.20*s[4]+0.15*e[14]+0.10*s[5]-0.10*epsilon);
  v[2]=clamp01(0.30*s[1]+0.20*s[7]+0.20*e[6]+0.15*e[12]+0.15*e[7]);
  v[3]=clamp01(0.35*s[6]+0.20*e[0]+0.15*e[1]+0.10*e[11]+0.20*s[5]);
  v[4]=clamp01(0.30*s[7]+0.25*s[5]+0.20*e[7]+0.15*e[9]+0.10*e[8]);
  v[5]=clamp01(0.25*s[3]+0.20*s[2]+0.15*e[3]+0.15*e[14]+0.15*e[6]+0.10*s[4]-0.10*epsilon);
  v[6]=clamp01(0.30*s[5]+0.25*s[6]+0.15*e[5]+0.15*e[7]+0.15*e[1]);
  v[7]=clamp01(0.25*s[0]+0.20*s[7]+0.20*e[12]+0.15*e[8]+0.20*e[6]);
  return v.map(Math.round);
}

let ec; 
function renderChart(struct16, eco, pot16){
  const el=document.getElementById('chart');
  if (ec) ec.dispose();
  ec = echarts.init(el, null, {renderer:'canvas'});
  const indicators = ecoNames.map(n=>({name:n, max:100}));
  const opt={
    backgroundColor: 'transparent',
    radar: [{
      indicator: indicators,
      center: ['50%','50%'],
      radius: '67%',
      splitNumber: 5,
      axisName: { color:'#cfe1ff', fontSize:12 },
      splitLine: { lineStyle:{color:'rgba(255,255,255,.10)'} },
      axisLine:  { lineStyle:{color:'rgba(255,255,255,.10)'} },
      splitArea: { areaStyle:{color:['transparent']} }
    }],
    tooltip: {show:false},
    series: [
      { type:'radar', name:'结构(投影)', symbolSize:3, areaStyle:{color:'rgba(124,155,255,.22)'}, lineStyle:{color:'#7c9bff',width:2}, data:[{value:struct16}] },
      { type:'radar', name:'生态(16)',   symbolSize:3, areaStyle:{color:'rgba(34,197,94,.18)'},  lineStyle:{color:'#22c55e',width:2,type:'dashed'}, data:[{value:eco}] },
      { type:'radar', name:'潜力(投影)', symbolSize:3, areaStyle:{color:'rgba(245,158,11,.18)'}, lineStyle:{color:'#f59e0b',width:2,type:'dotted'}, data:[{value:pot16}] }
    ]
  };
  ec.setOption(opt);

  const zr = ec.getZr();
  const card = document.getElementById('hoverCard');
  zr.on('mousemove', (params)=>{
    const rect = el.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const x = params.offsetX - cx, y = params.offsetY - cy;
    const ang = Math.atan2(y,x);
    const base = -Math.PI/2;
    let norm = ang - base; while (norm<0) norm+=Math.PI*2;
    const idx = Math.round(norm/(Math.PI*2/ecoNames.length)) % ecoNames.length;
    updateHoverCard(idx, struct16[idx], eco[idx], pot16[idx]);

    const pad=12;
    let left = params.offsetX + pad;
    let top  = params.offsetY + pad;
    const cw = card.offsetWidth || 260;
    const ch = card.offsetHeight || 160;
    if (left + cw > rect.width) left = params.offsetX - cw - pad;
    if (top  + ch > rect.height) top  = params.offsetY - ch - pad;
    card.style.left = `${left}px`;
    card.style.top  = `${top}px`;
    card.style.display='block';
  });
  zr.on('mouseleave', ()=>{ card.style.display='none'; });
}

function renderList(el, names, vals){
  el.innerHTML = names.map((n,i)=>`<span class="tag">${n}<b style="margin-left:6px">${vals[i]}</b></span>`).join('');
}

const badges=[]; function tag(t,sub){badges.push({t,sub:sub||''})}
function hi(x){return x>=70} function lo(x){return x<=50}
function midLo(x){return x>50 && x<66} function midHi(x){return x>=66 && x<70}
function runBadges(structs, eco, ENV){
  const [M,B,W,F,Cp,S,Br,Rk]=structs; const eps=envParams(ENV).epsilon;
  if (M>=72 && Cp<=55) tag('方向未锚定','高觉察但目标/取舍不清');
  if (M>=72 && B<=55)  tag('决策阻抗','高觉察但控制不足');
  if (M>=72 && S<=55)  tag('情绪复燃','高觉察但稳态不足');
  if (hi(Rk) && hi(eps) && lo(W)) tag('硬扛但恢复慢');
  if (hi(Rk) && hi(eps) && midLo(W)) tag('硬扛并能转圜（恢复一般）');
  if (hi(Rk) && hi(eps) && midHi(W)) tag('硬扛且具韧性','高强度+高噪声，注意恢复与配速');
  if (hi(Rk) && eps<=40 && lo(W)) tag('持久稳推');
  if (hi(Rk) && eps<=40 && midHi(W)) tag('持久且敏捷');
  if (hi(Rk) && midHi(W) && eps<=50) tag('遇变不崩');
  if (hi(Rk) && midHi(W) && hi(eps)) tag('顶得住但返工变多');
  if (hi(F) && lo(S) && lo(Br)) tag('反应性攻击');
  if (hi(F) && S>=60) tag('高能但不失控','冲突可降级');
  if (hi(F) && Br>=65) tag('高能但能软着陆');
  if (hi(F) && S>=60 && Br>=65) tag('强号召');
  if (hi(F) && lo(S)) tag('高能失控','长期摩擦增');
  if (hi(F) && lo(Br)) tag('极化领导','阵营分化');
  if (hi(B) && midHi(W) && eps<=50) tag('敏捷有边');
  if (hi(B) && midHi(W) && hi(eps)) tag('快变但返工风险');
  if (hi(B) && midLo(W) && eps<=50) tag('稳中求进');
  if (hi(B) && lo(W) && hi(eps)) tag('刚性维稳');
  if (hi(B) && lo(W) && eps<=50) tag('稳定高效');
  if (hi(B) && midHi(W)) tag('改动可承受（连续性略降）');
  if (M>=72 && Cp>=65 && S>=60) tag('清晰拍板');
  if (M>=72 && Cp<=55 && S>=60) tag('看得清但目标摇摆');
  if (M>=72 && Cp>=65 && S<=55) tag('清晰但起伏大');
  if (Cp>=70 && Br>=70 && lo(W)) tag('坚定且可协同');
  if (Cp>=70 && Br>=70 && midHi(W)) tag('善意协调但边界弹性增','需外部锚定');
  if (Cp>=70 && lo(Br) && lo(W)) tag('坚定但强硬');
  if (Cp>=70 && Br>=70 && !lo(W)) tag('坚定且易协同');
  if (hi(W) && F>=66 && hi(B)) tag('创变执行');
  if (hi(W) && F>=66 && lo(B)) tag('创意多但落地难');
  if (hi(W) && B>=50 && B<=65 && F>=50 && F<=65) tag('弹性改进');
  if (W<=50 && B>=50 && B<=65 && F>=50 && F<=65) tag('稳中求进');
  if (hi(B) && hi(S) && lo(W)) tag('高连续性');
  if (hi(B) && hi(S) && midHi(W)) tag('连续性略降但韧性提升');
  if (hi(B) && lo(S) && lo(W)) tag('规则在但情绪打断');
  if (hi(B) && hi(S) && !lo(S)) tag('稳定可靠');
  if (hi(Br) && eps<=50 && F>=66) tag('号召+凝聚');
  if (hi(Br) && hi(eps) && F>=66) tag('动员强但协调成本高');
  if (lo(Br) && hi(eps) && F>=66) tag('冷硬推进');
  if (lo(Br) && eps<=50 && F>=66) tag('强势但可控');
  if (Cp>=70 && hi(Rk) && lo(Br)) tag('坚定有边界但协作摩擦');
  if (Cp>=70 && hi(Rk) && hi(Br)) tag('一致对外');
  if (Cp>=70 && !hi(Rk) && Br>=50) tag('原则仍在但执行弹性增');
  if (S>=75 && F<=55 && eps<=50) tag('高冷静');
  if (S>=75 && F>=72 && eps<=50) tag('冷静转强势推进');
  if (S>=75 && F<=55 && hi(eps)) tag('冷静→压抑感','效率下降，注意恢复节律');
}
function renderBadges(){
  const el=document.getElementById('badges');
  el.innerHTML = badges.length? badges.map(b=>`<span class="badge">${b.t}${b.sub?`｜${b.sub}`:''}</span>`).join('') : '<span class="muted">（暂无触发）</span>';
}

function updateHoverCard(idx, vStruct, vEco, vPot){
  document.getElementById('hcTitle').textContent = ecoNames[idx];
  document.getElementById('hcEco').textContent = Math.round(vEco);
  document.getElementById('hcStruct').textContent = Math.round(vStruct);
  document.getElementById('hcPot').textContent = Math.round(vPot);
  const sIdx = Object.entries(mapSE).filter(([si,arr])=> arr.includes(idx)).map(([si])=> +si);
  const pIdx = Object.entries(pot2eco).filter(([pi,arr])=> arr.includes(idx)).map(([pi])=> +pi);
  const tags = [];
  if (sIdx.length){ tags.push(...sIdx.map(i=>`<span class="tag">${structNames[i]}</span>`)); }
  if (pIdx.length){ tags.push(...pIdx.map(i=>`<span class="tag">${potNames[i]}</span>`)); }
  if (idx===7){ tags.push(`<span class="tag">连续性×韧性</span>`); }
  document.getElementById('hcLinks').innerHTML = tags.join('') || '<span class="muted">（无）</span>';
}

function main(){
  const diag=document.getElementById('diag');
  let {SELF,ENV}=loadVectors();
  if (!SELF || !ENV){
    const d=injectDemo(); SELF=d.self; ENV=d.env;
    diag.innerHTML = '<span class="ok">已注入演示数据（可用于自测）</span>';
  }else{
    diag.innerHTML = '<span class="ok">数据已接入</span>';
  }
  const structs = toStructures5(SELF).map(Math.round);
  const eco = toEcology(structs, ENV);
  const pots = toPotentials(structs, eco, ENV);

  const bucketS=Array.from({length:16},()=>[]);
  Object.entries(mapSE).forEach(([si,arr])=>arr.forEach(ax=>bucketS[ax].push(structs[+si])));
  const struct16=bucketS.map(list=>list.length? Math.round(list.reduce((a,b)=>a+b,0)/list.length):50);
  const bucketP=Array.from({length:16},()=>[]);
  Object.entries(pot2eco).forEach(([pi,arr])=>arr.forEach(ax=>bucketP[ax].push(pots[+pi])));
  const pot16=bucketP.map(list=>list.length? Math.round(list.reduce((a,b)=>a+b,0)/list.length):50);

  renderChart(struct16, eco, pot16);

  renderList(document.getElementById('listStruct'), structNames, structs);
  renderList(document.getElementById('listEco'), ecoNames, eco);
  renderList(document.getElementById('listPot'), potNames, pots);

  badges.length=0; runBadges(structs, eco, ENV); renderBadges();
}

document.getElementById('btnDemo').addEventListener('click', ()=>{ injectDemo(); main(); });
document.getElementById('btnClear').addEventListener('click', ()=>{ clearData(); location.reload(); });

main();
</script>
</body>
</html>
